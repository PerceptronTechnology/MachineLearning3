# marimo で機械学習の notebook を作ってみよう

> **【注意】** marimo を用いたコードは、荒木雅弘 : 『Pythonではじめる機械学習』（森北出版, 2025）には含まれておりません。本ドキュメントは、同書の補足資料です。

> **TL;DR:** 次世代の Python notebook 環境として、marimo が注目されています。marimo は、コードセル間の関係を DAG（有向非巡回グラフ）として管理することで、ある変数の値を変更すると、その変数に依存するセルが自動的に再実行されます。この機能によって、変数の値をスライダーやドロップダウンリストでインタラクティブに変更すると、その値を利用して計算したデータのグラフなどが自動的に更新される、というような使い方が可能になります。また、notebook は Python のコードとして保存されるので、Git やコーディングエージェントとの相性が良い点もメリットとして挙げられます。

## marimo に至る道

> この章では、なぜ marimo が開発されたのかということを、REPL、IPython、Jupyter notebook から marimo に至るまでの過程を振り返りながら説明します。先に marimo の使い方について知りたい方は、次の章に進んでください。

あなたは現在、機械学習の勉強中でしょうか。そして、プログラミング言語は、Python をお使いでしょうか。それならば、Jupyter notebook を使っている可能性が高いでしょう。 Jupyter notebook は、Google Colaboratory や AWS SageMaker Studio Lab など、ある程度の範囲までは無料で使えるサービスがあり、現状では、初学者が Python で機械学習を勉強するには最適な環境であるといえるでしょう。

このような状況で、最近、marimo という新しい notebook 環境が、ちらほらと話題に上るようになりました。[marimo の公式サイト](https://marimo.io/) を見ると、基本的にはセルに Python のコードを書いて実行するものに見え、Jupyter notebook とそれほど異なっているような印象は受けません。表示されたグラフがかっこよく動いていますが、機械学習を学ぶ上での必要性は、あまり感じられないかもしれません。

現状の Jupyter notebook に特に不便を感じていないのならば、新たに marimo を学ぶ必要は特にないように思えます。しかし、Jupyter notebook は 2010 年代初頭に開発されたものであり、その後に発展した Python のエコシステムのメリットを、十分には反映できていない面があります。また、生成AIによるコーディングが発展してゆく中で、それらが十分に活用できていないようにも見えます。これらを考えると、Python の notebook 環境について、そろそろ一から作り直すべきタイミングかもしれません。marimo は、その選択肢のひとつとして動き出したものです。

marimo のホームページには、marimo の特徴として「AI-native で reactive な notebook であり、Git-friendly である」という説明があります。これらはそのまま裏返すと、Jupyter notebook の欠点ということになります。そうすると、marimo を使ってみるかどうか判断するためには、Jupyter notebook とは何か、というところから説明しなければならないのですが、そのためにはそのバックグラウンドの Ipython とは何か、さらにその前身の REPL とは何か、というところにさかのぼって説明を始めることになります。

![repl2marimo](../images/repl2marimo.svg)

### REPL から Jupyter notebook まで

REPL は Read（読み込み）、Eval（評価）、Print（表示）、Loop（繰り返し）の頭文字をとった略語です。プログラムのコードを行単位（あるいは実行命令単位）でコンソールから読み込ませると、それ以前の実行結果を反映させた状態でコードを評価（すなわち実行）し、その結果が式やオブジェクトであれば値を表示します。そして、それ以前のものも含めた評価結果（変数値や関数定義など）を保持したまま、次の入力を待って同じ事を繰り返す仕組みです。新しいプログラミング言語の多くには、REPL が備わっています。

Python がインストールされている環境で、ターミナルで `python` コマンドを実行すると、REPL が起動します。ここで Python のコードを一行ずつ入力して実行することができます。履歴は上下の矢印キーでたどれます。また、コードの途中で tab キーを押すと、補完候補が表示されます。REPL には、このような簡易なインターフェースしか用意されていないので、Python の文法の確認や、ライブラリ関数を電卓代わりに使うような用途が想定されているといえます。

```console
$ python
Python 3.13.4 (main, Jun  4 2025, 17:37:06) ...
>>> import math
>>> math.log2(32)
5.0
>>>exit()
```

IPython ライブラリをインストールして、ターミナルで `ipython` コマンドを実行すると、IPython カーネルが起動します。IPython カーネルは、Python の REPL を拡張したものです。入出力が `In[1]:/Out[1]` 形式の番号付きになるので、特定の出力を `Out[1]` のように番号で参照することが可能になりました（直前の出力は `_` で参照可能）。また、tab によって表示された補完候補を矢印キーで選択して、入力を楽にすることが可能です。

IPython の最大の特徴は、マジックコマンドとシェルコマンドが使用できることです。マジックコマンドは、`%` または `%%` で始まるコマンドで、コード実行に対して、メタ的に働きます。例えば `%time` はコードの実行時間を計測します。シェルコマンドは、`!` で始まるコマンドで、Python が動いている OS の機能を、サブプロセルとして呼び出すものです。例えば Linux 環境で `!ls` と実行すれば、カレントディレクトリのファイル一覧を表示します。シェルコマンドを利用することで、その実行結果をコードに取り込んだり、Ipython カーネルを終了することなくライブラリをインストールすることが可能になります。

```console
$ ipython
Python 3.13.4 (main, Jun  4 2025, 17:37:06) ...
...
IPython 9.7.0 -- An enhanced Interactive Python. ...
In [1]: %time y = [x**2 for x in range(10000000)]
CPU times: user 278 ms, sys: 155 ms, total: 434 ms
Wall time: 429 ms

In [2]: 
```

この IPython の実行環境に、ブラウザベースのインターフェースを提供したものが IPython notebook です。IPython notebook は、コードセルとマークダウンセルの 2 種類のセルからなります。コードセルには Python のコードを記述し、そのセルが実行されると、そこに書かれたコードが IPython カーネルで実行されます。そして、実行結果（テキストや画像）が、コードセルの下に表示されます。マークダウンセルは、マークダウン形式で書かれたテキストを、ブラウザのレンダリングエンジンが HTML に変換して表示します。マークダウンセルには、数式や画像を埋め込むことが可能なので、一連の実験結果を説明するドキュメントを、コードとともに作成することができます。

このように、ブラウザベースのインターフェースとコードを実行するカーネルを分離させると、カーネルを入れ替えることで、Python 以外の言語を使うことも可能になります。そのようにして IPython notebook は Jupyter notebook へと発展していきました（Jupyter という名前には、プロジェクト発足当時にコアとしてサポートしていたプログラミング言語名 Julia, Python, R の一部が含まれています）。

Jupyter notebook では、このようなコード、マークダウン、画像（Base64 で文字としてエンコードされたデータ）などが混在したドキュメントを1つのファイルとして JSON 形式に記述し、`.ipynb` ファイルとして保存します。

![jb](../images/jb.svg)

### なぜ marimo か

ここでは、冒頭で挙げた marimo の特徴「AI-native で reactive な notebook であり、Git-friendly である」点を、Jupyter notebook と比較しながら説明していきます。

#### AI-native である

AI-nativeとは、notebook 作成中に、生成AI（主として大規模言語モデル (LLM)）によるコード補完・コード生成・データやエラーについてのチャットが利用できる、ということを意味します。

これについては、Jupyter notebook でも既に同様のことができていると思われるかもしれません。しかし、Jupyter notebook の場合は、その構造がまずあって、notebook を作成する環境（Google colaboratory で Gemini を使う場合や、VSCode で GitHub Copilot を使う場合など）が、適合する拡張機能を提供するという形になります。これらは、それぞれのコーディング環境の制約を受けることになります。

一方 marimo では、処理系が直接 LLM を使っているので、現在の LLM が得意なことを、最大限に引き出すような仕組みが組み込まれています。現在の実装では、notebook のコードは、LLM にコンテキストとして渡されているので、高精度なコード生成・補完が可能です。また、メモリに保持された変数の値を `@変数名` を使って参照できるので、LLM に対して、現在の変数の内容を踏まえた質問が可能です。

また、コーディングエージェントの使用を前提に考えると、notebook が Python のコードであることは重要です。そのままソースコードとして扱い、test ケースを自動生成したり、CI/CD パイプラインに組み込んだりすることが可能になるからです。marimo は、このようなコーディングエージェントからの利用を可能にする MCP Server の機能や、コード生成・補完時に最新の情報を参照する MCP client の機能を備えています。

![AInative](../images/AInative.svg)

#### reactive である

reactive であるとは、marimo の出力が、セルの実行順序に依存せず、DAG で管理された変数の依存関係に基づいて自動的に更新されるということを意味します。DAG (directed acyclic graph) の訳語は、有向非巡回グラフです。ここでのグラフは、棒グラフや線グラフなどのデータを可視化したものではなく、ノード（頂点）とエッジ（辺）からなるデータ構造です。有向グラフとは、エッジに向きがあるグラフです。非巡回とは、グラフ内に閉路（ループ）が存在しないことを意味します。

Jupyter notebook でのコーディングでは、あるセルの実行でエラーが出た場合、以前に実行した別のセルを修正・実行してから、当該セルを実行し直す、ということがよくあります。Jupyter notebook から呼び出される IPython カーネルは、実行を指示された通りに変数値や関数定義を上書きしていくため、試行錯誤的にあちこちのセルを実行すると、上から順番にセルを実行したときとは、結果が異なったり、エラーが発生したりします。このような理由で、Jupyter notebook で作成されたコードを他人と共有するときは、「カーネルをリセットして、冒頭から順番にセルを実行して動作確認をすること」という規則が設けられている場合もあります。

これに対して marimo では、セルに出現するクラス名・関数名・変数名などを処理系が解析して、セルをノードとする DAG を自動的に構築し、セルの依存関係を管理します。これによって、たとえばあるセルで変数値を変更すると、それに影響を受ける他のセル（のみ）が自動的に再実行されます。

このことが、同じ名前を持つ変数や関数を異なるセルで定義することができない、という marimo 独自のルールにつながっています。たとえばあるセルで `x = 1` と定義すると、他のセルでは、`x` の参照のみが許されます。このルールは、異なるセルでの定義を認めてしまうと、その変数や関数を別のセルで使うときに、どちらのセルに依存するのかを決められない、ということから設定されています。変数名の衝突を回避するには、変数名をアンダーバー `_` で始めるセルのローカル変数を使います。ここが、Jupyter notebook から marimo に移行するときに、最初に戸惑う点になるでしょう。

![DAG](../images/DAG.svg)

#### Git-friendly である

Git-friendly であるとは、notebook が、実行可能な Python のコードであるため、Git でのバージョン管理に適していることを意味します。

Jupyter notebook の `.ipynb` ファイルは、notebook の形式情報・コード・実行結果・マークダウンによる説明などをひとつの JSON 形式ファイルで保存します。すべての情報がひとつのファイルにまとめられていることは便利ですが、少しコードを変更しただけでも、多くの部分が書き換えられ、Git の差分表示が見にくくなるという欠点があります。

一方、marimo では、notebook の内容が Python のコードなので、コードの変更部分のみが差分として表示され、Git でのバージョン管理が容易になります。また、通常の Python コードであるということは、pytest を用いたテストの自動実行や、それを踏まえた CI/CD パイプラインへの組み込みが容易であるという利点もあります。

Git-friendly であるという点は、コーディングエージェントとの相性の良さにもつながります。現状のコーディングエージェントは、Git のリポジトリでの操作を前提としており、要所要所で人間が介入する場合でも、プルリクエストが読みやすいことや、その評価が自動化できる点が重要になります。

### まとめ

ここでは、marimo がなぜ開発されたのか、という背景と、Jupyter notebook と比較したときの marimo の特徴について説明しました。

marimo を使う理由の追加事項として、Python のパッケージマネージャ uv との相性が良いことが挙げられます。uv は、Python の仮想環境をプロジェクトごとに自動的に切り替えることができるパッケージマネージャです。uv の仮想環境で marimo を動かすと、notebook の実行中に不足しているライブラリがあれば、自動的にインストールを促すメッセージが表示され、承認によって高速にインストールされます。これによって、仮想環境を操作する煩わしさを感じることなくコーディングを進めることができます。

なお、本ドキュメントは、marimo が Python notebook 環境の完成形であると主張するものではありません。現在の Python のエコシステムと生成AIの活用を前提とした場合に、Python での試行錯誤的なコーディング、結果の共有・再利用、知識ベースへの統合までを考慮した新しい方式が数ヶ月後に提案され、marimo は消えてしまうかもしれません。しかし、そのときに、Jupyter notebook を超えるためにこれまでどのような取り組みがあったかを知っておくことで、新しい提案が真に有益なものかどうかを判断することができるでしょう。
